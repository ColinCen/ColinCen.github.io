<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/tango.ico?v=5.0.1" />






<meta name="description" content="本次新生赛题目还是很难的,部分题解还未看懂,先贴上来.
棋盘村原题:棋盘村
算法思想递推,比赛时用了bfs结果超时了,赛后看来还是递推简单明了.另外递推时要处理边界.
程序代码#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;
using namespace std;
int n,m,x,y;
int g[100][100];
long long">
<meta property="og:type" content="article">
<meta property="og:title" content="16哈理工新生网络赛">
<meta property="og:url" content="http://yoursite.com/2016/11/29/16哈理工新生网络赛/index.html">
<meta property="og:site_name" content="Colin's blog">
<meta property="og:description" content="本次新生赛题目还是很难的,部分题解还未看懂,先贴上来.
棋盘村原题:棋盘村
算法思想递推,比赛时用了bfs结果超时了,赛后看来还是递推简单明了.另外递推时要处理边界.
程序代码#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;
using namespace std;
int n,m,x,y;
int g[100][100];
long long">
<meta property="og:updated_time" content="2016-11-30T13:25:08.293Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="16哈理工新生网络赛">
<meta name="twitter:description" content="本次新生赛题目还是很难的,部分题解还未看懂,先贴上来.
棋盘村原题:棋盘村
算法思想递推,比赛时用了bfs结果超时了,赛后看来还是递推简单明了.另外递推时要处理边界.
程序代码#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory.h&amp;gt;
using namespace std;
int n,m,x,y;
int g[100][100];
long long">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/11/29/16哈理工新生网络赛/"/>

  <title> 16哈理工新生网络赛 | Colin's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Colin's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">A football fan,an English lover and a coder</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                16哈理工新生网络赛
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-29T22:39:40+08:00" content="2016-11-29">
              2016-11-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/acm/" itemprop="url" rel="index">
                    <span itemprop="name">acm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/29/16哈理工新生网络赛/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/29/16哈理工新生网络赛/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本次新生赛题目还是很难的,部分题解还未看懂,先贴上来.</p>
<h1 id="棋盘村"><a href="#棋盘村" class="headerlink" title="棋盘村"></a>棋盘村</h1><p><strong>原题:<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2293" target="_blank" rel="external">棋盘村</a></strong></p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>递推,比赛时用了bfs结果超时了,赛后看来还是递推简单明了.另外递推时要处理边界.</p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>#include &lt;iostream&gt;
#include &lt;memory.h&gt;
using namespace std;
int n,m,x,y;
int g[100][100];
long long ans[100][100];
void robber_cover()
{
    g[x][y]=0;
    g[x+2][y+1]=0;
    g[x+2][y-1]=0;
    g[x+1][y+2]=0;
    g[x+1][y-2]=0;
    g[x-2][y+1]=0;
    g[x-2][y-1]=0;
    g[x-1][y+2]=0;
    g[x-1][y-2]=0;

}
int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        memset(g,-1,sizeof(g));
        memset(ans,0,sizeof(ans));
        scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;x,&amp;y);
        robber_cover();
        ans[0][0]=1;
        for(int i=1;i&lt;=n;i++)
            if(g[i][0])
                ans[i][0]=1;
            else break;
        for(int i=1;i&lt;=m;i++)
            if(g[0][i])
                ans[0][i]=1;
            else break;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
                if(g[i][j])
                ans[i][j]=ans[i-1][j]+ans[i][j-1];
        printf(&quot;%lld\n&quot;,ans[n][m]);
    }
    return 0;    
} 
</code></pre><h1 id="修建传送门"><a href="#修建传送门" class="headerlink" title="修建传送门"></a>修建传送门</h1><p><strong>原题:<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2294" target="_blank" rel="external">修建传送门 </a></strong></p>
<h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>对于任意点K，其与点1之间的最短路有两种情况：<br>（1）直接从点1走到K；<br>（2）从1走到点A，通过A直接跳到点B，再从B走到K。<br>或者说，这条最短路等于min（直接从1走到K的距离，从1走到点A通过A跳到B在从B走到K的距离）。<br>设点I和J之间的直线距离为DIS[I,J]，则：<br>在第（1）种情况下，最短路长度为DIS[1,K]；<br>在第（2）种情况下，最短路长度为DIS[1,A] + DIS[B,K];<br>由于DIS[1,A]是一个常数（因为A固定），而与K有关的只有B，应直接选择A=1使DIS[1,1] = 0.（也就是说传送门的第一个点一定要建在1点上）。<br>对当前枚举的第二个传送点位置B,必有唯一一个点C具有如下性质：<br>DIS[1,C] &lt;= DIS[C,K] 且 DIS[1,C+1]　＞ DIS[C,K]<br>此时距离1最长的点为C，C+1或N中的一个。<br>留意到随着B的递增，C是不递减的，所以在O（n）枚举B的同时只需要O（1）就可以找到Ｃ。</p>
<h2 id="程序代码-1"><a href="#程序代码-1" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 1100000;
int i, j, r, n, m, ansi, ansj, ansr;
long long ans;
long long p[maxn];

inline void make() {
    long long temp;
    ans = p[n];
    i = j = 1;
    while (i &lt;= n) {
        while (j &lt; i &amp;&amp; p[j] &lt;= p[i] - p[j])
            j++;
        temp = max(p[i] - p[j], p[j-1]);
        temp = max(p[n] - p[i], temp);
        if (temp &lt; ans) {
            ans = temp;
            ansi = i;
            ansj = j;
        }
        i++;
    }
}

int main()
{
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        memset(p, 0, sizeof(p));
        scanf(&quot;%d&quot;, &amp;n);
        for (i = 2; i &lt;= n; i++) {
            scanf(&quot;%lld&quot;, &amp;p[i]);
            p[i] += p[i-1];
        }
        make();
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}
</code></pre><h1 id="方方正正"><a href="#方方正正" class="headerlink" title="方方正正"></a>方方正正</h1><p><strong>原题:<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2295" target="_blank" rel="external">方方正正 </a></strong></p>
<h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><p>首先需要判断行和列的总和是否相等，因为它们都应该是整个矩阵的所有元素之和。如果他们不相等则这个矩阵肯定不存在。<br>这道题的贪心策略是，把列和从大到小枚举，对每个列和，按行和从大到小的顺序进行选择填上1，然后该行的行和减去1.这种贪心策略之所以有效，是因为这种策略会使各行的行和趋向于平均，尽可能地使行和减为零的情况推迟发生，而行和减为零意味着，当前可选的行数减少1，因此后面的计算可选择方法肯定比这种贪心的策略要少。</p>
<h2 id="程序代码-2"><a href="#程序代码-2" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
using namespace std;
const int size=100000;                //最大行列数
int a[size],b[size];                //分别保存行和与列和
int main(){
    int r,c,i,j;
    long long s,t;                    //枚举时比较的行和与列和总数
    while(scanf(&quot;%d%d&quot;,&amp;r,&amp;c)==2){//输入整数r,c直到文件结束
        for(i=0,s=0; i&lt;r; i++){
            scanf(&quot;%d&quot;,&amp;a[i]);        //输入行和
            s+=a[i];                    //累加行和
        }
        for(i=0,t=0; i&lt;c; i++){
            scanf(&quot;%d&quot;,&amp;b[i]);        //输入列和
            t+=b[i];                    //累加列和
        }
        if(s!=t){                        //如果行和与列和总数不相等
            printf(&quot;NO\n&quot;);            //则不可能有解
            continue;
        }
        sort(a,a+r);                    //行和排序
        sort(b,b+c);                    //列和排序
        for(i=j=0,t=s=0; i&lt;c; i++){//从大到小枚举列和
            t+=b[c-i-1];                //当前已枚举的列和总数
            s+=r-j;                    //当前可用的行和总数
            while(j&lt;r&amp;&amp;a[j]&lt;i+1){    //如果某行和小于枚举列数
                s-=i+1-a[j];            //把行和总数多算出来的部分减去
                j++;
            }
            if(s&lt;t) break;            //如果可用行和小于当前列和则不可能有解
        }
        printf(i==c?&quot;YES\n&quot;:&quot;NO\n&quot;);//输出答案
    }
    return 0;
}
</code></pre><h1 id="Diamond"><a href="#Diamond" class="headerlink" title="Diamond"></a>Diamond</h1><p><strong>原题:<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2298" target="_blank" rel="external">Diamond </a></strong></p>
<h2 id="程序代码-3"><a href="#程序代码-3" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
const int maxn=1001;    //矩形最大边长

int f[maxn][maxn];        //以[0,m]×[0,n]为包含菱形的最小矩形的菱形的个数
long long g[maxn][maxn];//在[0,m]×[0,n]以m,n为边界的菱形的个数
long long h[maxn][maxn];//在[0,m]×[0,n]中菱形的个数
//扩展欧基里德算法，返回结果为最大公约数d，且ax+by=d
int egcd(int a,int b,long long &amp;x,long long &amp;y)
{
    long long k;            //临时变量
    int d;                    //最大公约数
    if (b==0)                //终止条件
    {
        x=1;                //满足终止条件时x的值
        y=0;                 //满足终止条件时y的值
        return a;            //最大公约数为a
    }
    else
    {
        d=egcd(b,a%b,x,y);    //递归求解
        k=a/b;
        k=x-k*y;                //临时变量用于交换两个数
        x=y;                    //扩展欧基里德算法中，从上一层得到x=y
        y=k;                    //扩展欧基里德算法中，从上一层得到y=x-(a/b)*y
        return d;                //最大公约数为递归求解结果
    }
}
//计算区间的上下界
void cal_bound(long long x,long long step,long long &amp;l,long long &amp;r,int lb,int rb)
{
    int temp;
    if (step&lt;0)                //当步长为负数时，进行镜像调整使得步长为正
    {
        x=-x;                    //x取相反数
        step=-step;            //步长取相反数
        temp=lb;
        lb=-rb;
        rb=-temp;                //把左右边界取相反数并且交换
    }
    //求最小的l使x+l*step&gt;=lb
    if (lb-x&gt;=0)                //左边界在已知解的右边
        l=(lb-x+step-1)/step;
    else                        //左边界在已知解的左边
        l=(lb-x)/step; 
    //求最大的r使x+r*step&lt;=rb
    if (rb-x&gt;=0)                 //右边界在已知解的右边
        r=(rb-x)/step;
    else                        //右边界在已知解的左边
        r=(rb-x-step+1)/step;
    return;
}
//求ax+by=c在lx&lt;=x&lt;=rx且ly&lt;=y&lt;=ry时整数解的个数
int cal(int a,int b,int c,int lx,int rx,int ly,int ry)
{
    long long x,y,dx,dy,l1,r1,l2,r2;
    int d;
    d=egcd(abs(a),abs(b),x,y);    //使用扩展欧基里德算法
    if (c%d!=0)                    //不存在解的情况
        return 0;
    if (a&lt;0)                        //如果a为负数，则相应调整x
        x=-x;
    if (b&lt;0)                         //如果b为负数，则相应调整y
        y=-y;
    x*=c/d;                        //求出其中一个解的x值
    y*=c/d;                        //求出其中一个解的y值
    dx=b/d;                        //x的变化步长
    dy=-a/d;                        //y的变化步长
    cal_bound(x,dx,l1,r1,lx,rx);//通过x求t的左右边界
    cal_bound(y,dy,l2,r2,ly,ry);//通过y求t的左右边界
    if (l1&lt;l2)                    //取左边界的最大值
        l1=l2;
    if (r1&gt;r2)                    //取右边界的最小值
        r1=r2;
    return r1-l1+1;                //返回解的个数
}
int init()                        //预处理函数
{
    int i,j,temp;
    for(i=1;i&lt;maxn;i++){        //枚举矩形的其中一边长
        for(j=1;j&lt;maxn;j++){    //枚举矩形的另一边长
            temp=cal(2*i,-2*j,i*i-j*j,0,i,0,j);//计算情况(1)的结果
            if (i==j)                //当矩形为正方形时，正方形重复计算了一次
                temp--;
            if (temp&gt;0)
                f[i][j]+=temp;    //将合法解累加到f数组中
            temp=cal(2*i,2*j,i*i+j*j,1,i-1,1,j-1);//计算情况(2)的结果
            if (i%2==0&amp;&amp;j%2==0)    //减去菱形面积为0的情况
                temp--;
            if (temp&gt;0)
                f[i][j]+=temp;    //将合法解累加到f数组中
            //从f数组到g数组的转移方程
            g[i][j]=g[i-1][j]+g[i][j-1]-g[i-1][j-1]+f[i][j];
            //从g数组到h数组的转移方程
            h[i][j]=h[i-1][j]+h[i][j-1]-h[i-1][j-1]+g[i][j];
        }
    }
    return 0;
}

int main()
{
    int m,n;
    init();                                //预处理
    while(scanf(&quot;%d%d&quot;,&amp;m,&amp;n)!=EOF){    //输入整数m,n直到文件结束
        printf(&quot;%lld\n&quot;,h[m][n]);        //输出答案
    }
    return 0;
}
</code></pre><h1 id="FBI-tree"><a href="#FBI-tree" class="headerlink" title="FBI tree"></a>FBI tree</h1><p><strong>原题:<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2299" target="_blank" rel="external">FBI tree </a></strong></p>
<h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>可以直接二分或者递归,不需要保存每一个字串,只需要找到长度为一的字串,判断是0还是1,就能判断双亲节点.</p>
<h2 id="程序代码-4"><a href="#程序代码-4" class="headerlink" title="程序代码"></a>程序代码</h2><h3 id="递归建树"><a href="#递归建树" class="headerlink" title="递归建树"></a>递归建树</h3><pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
using namespace std;
char s1[2]=&quot;0&quot;,s2[2]=&quot;1&quot;;
struct tree{
    char tag;
    tree *left,*right;
};
void create(tree *t,char *str,int len)
{
    if(len==1)
    {
        t-&gt;left=t-&gt;right=NULL;
        if(strstr(str,s1)&amp;&amp;!strstr(str,s2))
            t-&gt;tag=&apos;B&apos;;
        else if(!strstr(str,s1)&amp;&amp;strstr(str,s2))
            t-&gt;tag=&apos;I&apos;;
    }
    else
    {
        tree *r,*l;
        char temp1[550],temp2[550];
        int tt,p=0;
        strncpy(temp1,str,len/2);
        r = new tree;
        l = new tree;
        t-&gt;left=l;
        t-&gt;right=r;

        tt=len/2;
        while(tt&lt;len)
            temp2[p++]=str[tt++];
        temp2[p]=&apos;\0&apos;;

        if(strstr(temp1,s1)&amp;&amp;strstr(temp1,s2))
            l-&gt;tag=&apos;F&apos;;
        else if(strstr(temp1,s1)&amp;&amp;!strstr(temp1,s2))
            l-&gt;tag=&apos;B&apos;;
        else if(!strstr(temp1,s1)&amp;&amp;strstr(temp1,s2))
            l-&gt;tag=&apos;I&apos;;
        create(t-&gt;left,temp1,len/2);

        if(strstr(temp2,s1)&amp;&amp;strstr(temp2,s2))
            r-&gt;tag=&apos;F&apos;;
        else if(strstr(temp2,s1)&amp;&amp;!strstr(temp2,s2))
            r-&gt;tag=&apos;B&apos;;
        else if(!strstr(temp2,s1)&amp;&amp;strstr(temp2,s2))
            r-&gt;tag=&apos;I&apos;;
        create(t-&gt;right,temp2,len/2);
    }
}
void print(tree *t)
{
    if(t)
    {
        print(t-&gt;left);
        print(t-&gt;right);
        printf(&quot;%c&quot;,t-&gt;tag);
    }
}
int main()
{
    int T,N;
    char str[1200];
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        scanf(&quot;%d&quot;,&amp;N);
        int len=1;
        while(N--)
            len&lt;&lt;=1;
        tree *R;
        R= new tree;
        scanf(&quot;%s&quot;,str);
        if(strstr(str,s1)&amp;&amp;strstr(str,s2))
            R-&gt;tag=&apos;F&apos;;
        else if(strstr(str,s1)&amp;&amp;!strstr(str,s2))
            R-&gt;tag=&apos;B&apos;;
        else if(!strstr(str,s1)&amp;&amp;strstr(str,s2))
            R-&gt;tag=&apos;I&apos;;
        create(R,str,len);
        print(R);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
char Bins(char *str,int len)
{
    if(len==1)
    {
        if(str[0]==&apos;1&apos;) 
        {
            printf(&quot;I&quot;);
            return &apos;I&apos;;
        }
        else
        {
             printf(&quot;B&quot;);
             return &apos;B&apos;;
        }
    }
    else
    {
        char t1[1000],t2[1000];
        strncpy(t1,str,len/2);
        int tt=0,length=len/2;
        while(length&lt;len)
        {
            t2[tt++]=str[length++];
        }
        char temp1,temp2;
        temp1=Bins(t1,len/2);
        temp2=Bins(t2,len/2);
        if(temp1==&apos;I&apos;&amp;&amp;temp2==&apos;I&apos;)
        {
            printf(&quot;I&quot;);
            return &apos;I&apos;;
        }
        else if(temp1==&apos;B&apos;&amp;&amp;temp2==&apos;B&apos;)
        {
            printf(&quot;B&quot;);
            return &apos;B&apos;;
        }
        else
        {
            printf(&quot;F&quot;);
            return &apos;F&apos;;
        }
    }
}
int main()
{
    char str[2000];
    int T;
    int N;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        scanf(&quot;%d&quot;,&amp;N);
        int m=1;
        while(N--)
            m&lt;&lt;=1;
        scanf(&quot;%s&quot;,str);
        Bins(str,m);
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre><h1 id="下雪啦"><a href="#下雪啦" class="headerlink" title="下雪啦"></a>下雪啦</h1><p><strong>原题:<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2300" target="_blank" rel="external">下雪啦</a></strong></p>
<h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>每读入一片雪花，就将该雪花进行哈希操作，并判断哈希表里是否有相同的哈希值，如有相同的哈希值就从链表中一一取出并判断是否同构即可。</p>
<h2 id="程序代码-5"><a href="#程序代码-5" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;stdlib.h&gt;
#include &lt;vector&gt;
using namespace std;

const int M = 90001; //myhash函数，取余的数

int snow[100005][6]; //存储雪花信息
vector&lt;int&gt; myhash[M]; //myhash表，表中存储的是snow数组的下标

bool isSame(int a, int b)//判断a与b是否同样 
{
    for(int i=0;i&lt;6;i++)
    {
        //顺时针
        if((snow[a][0] == snow[b][i] &amp;&amp;
                    snow[a][1] == snow[b][(i+1)%6] &amp;&amp;
                    snow[a][2] == snow[b][(i+2)%6] &amp;&amp;
                    snow[a][3] == snow[b][(i+3)%6] &amp;&amp;
                    snow[a][4] == snow[b][(i+4)%6] &amp;&amp;
                    snow[a][5] == snow[b][(i+5)%6])
                ||   //逆时针
                (snow[a][0] == snow[b][i] &amp;&amp;
                 snow[a][1] == snow[b][(i+5)%6] &amp;&amp;
                 snow[a][2] == snow[b][(i+4)%6] &amp;&amp;
                 snow[a][3] == snow[b][(i+3)%6] &amp;&amp;
                 snow[a][4] == snow[b][(i+2)%6] &amp;&amp;
                 snow[a][5] == snow[b][(i+1)%6]))

            return true;
    }
    return false;
}

int main()
{
//freopen(&quot;h.out&quot;, &quot;w&quot;, stdout);
    int T;
    cin &gt;&gt; T;
    while (T--) {
        int ok = 0;
        int n;
        int i,j;
        cin&gt;&gt;n;
        for( i = 0; i &lt; n; i++) 
            for( j = 0; j &lt; 6; j++)
                cin&gt;&gt;snow[i][j];

        int sum, key;
        for(i = 0; i &lt; n; i++) 
        {
            sum = 0;//求出雪花六个花瓣的和
            for( j = 0; j &lt; 6; j++) 
                sum += snow[i][j];
            key = sum % M; //求出key

            //判断是否与myhash表中myhash[key]存储的雪花相同
            for(vector&lt;int&gt;::size_type j = 0; j &lt; myhash[key].size(); j++) 
            {
                if(isSame(myhash[key][j], i))//如相同 
                {
                    cout&lt;&lt;&quot;Twin snowflakes found.&quot;&lt;&lt;endl;
                    ok = 1;
                    break;
                }
            }
            if (ok) {
                break;
            }
            myhash[key].push_back(i);//若没找到相同的 
        }
        if (ok == 0) 
            cout&lt;&lt;&quot;No two snowflakes are alike.&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre><h1 id="Another-Tree"><a href="#Another-Tree" class="headerlink" title="Another Tree"></a>Another Tree</h1><p><strong>原题:<a href="http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=2302" target="_blank" rel="external">Another Tree</a></strong></p>
<h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p>本题乍看可以用树的划分等比较麻烦的方法去做，但实际上考虑到异或的特殊性质，不需要用到这些方法的方法。<br>首先回想我们是如何计算树上两点之间的距离的，先分别求出根到这两点之间的距离，记为l1, l2， 根到这两点的最近公共祖先的距离为lc.那么这两点距离就是（l1 ＋ l2）- (lc + lc).<br>然后回到原问题，我们要求的是两点之间的异或距离，同样先求出根到这两点的异或距离，记为x1, x2，根到这两点最近公共祖先距离为xc，那么这两点的异或距离就是x1⊕x2⊕xc⊕xc,所以异或距离就是x1⊕x2，那么我们只需要直到有多少点对，满足根分别到他们的异或距离异或后等于K。<br>于是我们把问题转换为一个很简单的问题，给出N个数字，问有多少对数字异或后等于K，枚举这些数字，然后统计枚举到的数字和K值出现的次数，加到答案里，问题就解决了。</p>
<h2 id="程序代码-6"><a href="#程序代码-6" class="headerlink" title="程序代码"></a>程序代码</h2><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
typedef long long LL;
const int MAXN = 500007;

struct Edge {
    int to, w;
    Edge* next;
};

Edge edges[MAXN * 2], * g[MAXN];
int nEdge;
int open[MAXN];
int a[MAXN];
bool vst[MAXN];
int hash[MAXN * 2];
int N, K;

inline void addEdge(int x, int y, int w) {
    Edge* p = &amp;edges[nEdge++];
    p-&gt;to = y;
    p-&gt;w = w;
    p-&gt;next = g[x];
    g[x] = p;
}

void bfs() {
    int i, j, x, m = 0;
    Edge* p;

    memset(vst, false, N);
    open[m++] = 0;
    vst[0] = true;
    for (i = 0; i &lt; m; ++i) {
        x = open[i];
        for (p = g[x]; p; p = p-&gt;next) {
            if (!vst[p-&gt;to]) {
                a[p-&gt;to] = (a[x] ^ p-&gt;w);
                vst[p-&gt;to] = true;
                open[m++] = p-&gt;to;
            }
        }
    }
    for (i = 0; i &lt; N; ++i) {
        ++hash[a[i]];
        assert(vst[i] == true);
    }
}

void input() {
    int i, x, y, w;

    scanf(&quot;%d%d&quot;, &amp;N, &amp;K);
    assert(2 &lt;= N &amp;&amp; N &lt;= 500000);
    assert(0 &lt;= K &amp;&amp; K &lt;= 500000);
    for (i = 0; i &lt; N; ++i) {
        g[i] = NULL;
    }
    nEdge = 0;

    for (i = 0; i &lt; N - 1; ++i) {
        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
        assert(0 &lt;= x &amp;&amp; x &lt; N);
        assert(0 &lt;= y &amp;&amp; y &lt; N);
        assert(1 &lt;= w &amp;&amp; w &lt;= 500000);
        addEdge(x, y, w);
        addEdge(y, x, w);
    }
}

void solve() {
    int i, j;
    LL ans = 0;

    bfs();
    for (i = 0; i &lt; N; ++i) {
        ans += hash[a[i] ^ K];
    }
    if (K == 0) ans -= N;
    ans /= 2;
    printf(&quot;%lld\n&quot;, ans);
    // clear the hash
    for (i = 0; i &lt; N; ++i) {
        hash[a[i]] = 0;
    }
}

int main() {
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    assert(T &lt;= 50);
    while (T--) {
        input();
        solve();
    }
    return 0;
}
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/28/蓝桥杯周练/" rel="next" title="蓝桥杯周练(部分题)">
                <i class="fa fa-chevron-left"></i> 蓝桥杯周练(部分题)
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/28/c++课程设计第四题/" rel="prev" title="c++课程设计">
                c++课程设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/11/29/16哈理工新生网络赛/"
           data-title="16哈理工新生网络赛" data-url="http://yoursite.com/2016/11/29/16哈理工新生网络赛/">
      </div>


    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/assassin.jpg"
               alt="Shen Hao" />
          <p class="site-author-name" itemprop="name">Shen Hao</p>
          <p class="site-description motion-element" itemprop="description">Colin's blog | acm |c++</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">51</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">45</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/colincen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#棋盘村"><span class="nav-number">1.</span> <span class="nav-text">棋盘村</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法思想"><span class="nav-number">1.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序代码"><span class="nav-number">1.2.</span> <span class="nav-text">程序代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#修建传送门"><span class="nav-number">2.</span> <span class="nav-text">修建传送门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法思想-1"><span class="nav-number">2.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序代码-1"><span class="nav-number">2.2.</span> <span class="nav-text">程序代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方方正正"><span class="nav-number">3.</span> <span class="nav-text">方方正正</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法思想-2"><span class="nav-number">3.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序代码-2"><span class="nav-number">3.2.</span> <span class="nav-text">程序代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Diamond"><span class="nav-number">4.</span> <span class="nav-text">Diamond</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序代码-3"><span class="nav-number">4.1.</span> <span class="nav-text">程序代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FBI-tree"><span class="nav-number">5.</span> <span class="nav-text">FBI tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法思想-3"><span class="nav-number">5.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序代码-4"><span class="nav-number">5.2.</span> <span class="nav-text">程序代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归建树"><span class="nav-number">5.2.1.</span> <span class="nav-text">递归建树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-number">5.2.2.</span> <span class="nav-text">二分查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#下雪啦"><span class="nav-number">6.</span> <span class="nav-text">下雪啦</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法思想-4"><span class="nav-number">6.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序代码-5"><span class="nav-number">6.2.</span> <span class="nav-text">程序代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Another-Tree"><span class="nav-number">7.</span> <span class="nav-text">Another Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法思想-5"><span class="nav-number">7.1.</span> <span class="nav-text">算法思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序代码-6"><span class="nav-number">7.2.</span> <span class="nav-text">程序代码</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shen Hao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name: "colincen2"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
